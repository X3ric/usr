# Utils

color() { # pipe to ansi color text
    local input
    read input
    local color_code
    if [[ $1 =~ ^[0-9]+$ ]]; then
        color_code=$1
    else
        case "$1" in
            black) color_code=0 ;;
            red) color_code=1 ;;
            green) color_code=2 ;;
            yellow) color_code=3 ;;
            blue) color_code=4 ;;
            magenta) color_code=5 ;;
            cyan) color_code=6 ;;
            white) color_code=7 ;;
            *) color_code=7 ;;
        esac
        color_code=$((color_code + 30))
    fi
    echo -e "\033[${color_code}m${input}\033[0m"
}

colortest() { # Color palette info
    [[ $# -eq 0 ]] && T='Text' 
    [[ -n "$1" ]] && T="$1"
    echo -e "\n  16-Color Mode:\n"
    echo -e "                   40m     41m     42m     43m     44m     45m     46m     47m"
    for FGs in '    m' '   1m' '  30m' '1;30m' '  31m' '1;31m' '  32m' '1;32m' '  33m' '1;33m' '  34m' '1;34m' '  35m' '1;35m' '  36m' '1;36m' '  37m' '1;37m';
    do
        FG=${FGs// /}
        echo -en " $FGs \033[$FG  $T  "
        for BG in 40m 41m 42m 43m 44m 45m 46m 47m;
        do
            echo -en "\033[$FG\033[$BG  $T  \033[0m"
        done
        echo
    done
    echo -e "\n  256-Color Mode:\n"
    for i in {0..255}; do
        if [[ -n "$1" ]]; then
            print -Pn " %F{$i}${(l:4::0:)1}%f "
        else
            print -Pn " %F{$i}${(l:4::0:)i}%f "
        fi
        if ((i % 16 == 15)); then
            echo
        fi
    done
}

fzf-splitted () { # fzf splitted view adaptation for tmux
    if [[ -n "$TMUX" ]]; then 
     fzf --reverse --ansi "$@"
    else 
     fzf-tmux -x --height ${FZF_TMUX_HEIGHT:-40%} --reverse --cycle --ansi "$@"
    fi 
}

kill-tty() { # kill all process in a tty
    if [[ ! -z $1 ]] ; then
        fuser -k "/dev/tty$1"
    else
        fuser -k "/dev/$(ps -e -o tty= | grep "tty" | sort -u | grep -v "?" | fzf-splitted)"
    fi
}

diskdump() { # Dump an image of a disk
    if [ "$#" -ne 1 ]; then
        echo "Usage: diskdump <OUTPUT_IMAGE_PATH>" | color 36
        return 1
    fi
    local output_image_path=$1
    local sd_card_device=$(lsblk -npo NAME,TYPE | awk '$2=="disk" {print $1}' | fzf-splitted --prompt="Select the disk to dump: ")
    if [[ -z $sd_card_device || ! -b "$sd_card_device" ]]; then
        echo "Invalid disk selection. Aborting."
        return 1
    fi
    read -q "REPLY?Are you sure you want to create an image from $sd_card_device? This may take some time. (y/n) "
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        echo "Creating disk image from $sd_card_device to $output_image_path..."
        sudo dd if="$sd_card_device" of="$output_image_path" bs=4M status=progress
        echo "Disk image created successfully."
    else
        echo "Operation cancelled."
        return 1
    fi
}

diskburn() { # Burn a image in a disk
  if [[ $# -ne 1 || ! -f $1 ]]; then
    echo "Usage: diskburn <path_to_disk_file>" | color 36
    return 1
  fi
  device=$(lsblk -npo NAME,TYPE | awk '$2=="disk" {print $1}' | fzf-splitted --prompt="Select a disk to burn the image to: ")
  if [[ -z $device || ! -b "$device" ]]; then
    echo "Invalid device selection. Aborting."
    return 1
  fi
  if mount | grep -q "$device"; then
    echo "Unmounting $device..."
    sudo umount "$device"
  fi
  echo "Burning the Image to $device..."
  sudo dd bs=4M if="$1" of="$device" status=progress oflag=sync
  echo "Ejecting $device..."
  sudo eject "$device"
  echo "Disk burning completed successfully."
}

diskfix() { # Fixes disk partition errors like unmountable disks
  local devices=($(lsblk -npo NAME,TYPE | awk '$2=="disk" {print $1}'))
  if [[ ${#devices[@]} -eq 0 ]]; then
    echo "No disks found. Aborting."
    return 1
  fi
  local device=$(echo "${devices[@]}" | tr ' ' '\n' | fzf-splitted --prompt="Select a disk to fix: ")
  if [[ -z $device || ! -b "$device" ]]; then
    echo "Invalid device selection. Aborting."
    return 1
  fi
  echo "Checking and repairing the file system on $device..."  | color 33
  sudo fsck -f -y "$device"
  echo "Disk fixing completed successfully." | color 36
}

diskformat() { # format disks utility
    local default_fs_type="ext4"
    local devices=($(lsblk -npo NAME,TYPE | awk '$2=="disk" {print $1}'))
    if [[ ${#devices[@]} -eq 0 ]]; then
        echo "No disks found. Aborting."
        return 1
    fi
    local device=$(echo "${devices[@]}" | tr ' ' '\n' | fzf-splitted --prompt="Select a disk to format: ")
    if [[ -z $device || ! -b "$device" ]]; then
        echo "Invalid device selection. Aborting."
        return 1
    fi
    if mountpoint -q "$device"; then
        echo "Unmounting $device..."
        sudo umount "$device"
        if [[ $? -ne 0 ]]; then
            echo "Unmounting failed. Aborting."
            return 1
        fi
    fi
    local fs_type="${1:-$default_fs_type}"
    echo "Formatting $device with $fs_type..."
    sudo mkfs -t "$fs_type" "$device"
    if [[ $? -eq 0 ]]; then
        echo "Disk formatting completed successfully."
        return 0
    else
        echo "Disk formatting failed. Please check the disk and try again."
        return 1
    fi
}

picom-cpumax() { # on 80% cpu disables picom temporally to evit lag
    local threshold=80
    [[ ! -z $1 ]] && threshold="$1"
    local cpuUsage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2 + $4}')
    if pgrep -x picom &>/dev/null; then
        if (( cpuUsage >= threshold )); then
            echo "High CPU usage detected. Stopping Picom."
            pkill -x picom
        fi
    else
        if (( cpuUsage < threshold )); then
            echo "CPU usage normalized. Starting Picom."
            picom &
        fi
    fi
}

desktop-exec() { # .desktop file runner
    if [ $# -eq 0 ]; then
        echo "Usage: $0 /path/to/your.desktop"
        exit 1
    fi
    desktop_file="$1"
    exec_command=$(grep -m 1 "^Exec=" "$desktop_file" | sed 's/^Exec=//')
    eval $exec_command
}

drun() { # run commands on file/dir size change
    [ -z "$1" ] && { echo "Usage: drun <command> [file/directory]"; return 1; }
    local cmd="$1"
    local target="${2:-$PWD}"
    [ ! -e "$target" ] && { echo "Error: File or directory '$target' not found."; return 1; }
    echo "Monitoring size of '$target' for changes..."
    local prev_size=$(du -sb "$target" | awk '{print $1}')
    while sleep 1; do
        local size=$(du -sb "$target" | awk '{print $1}')
        if [ "$prev_size" -ne "$size" ]; then
        prev_size="$size"
        zsh -ci $cmd
        fi 
    done
}

qrscan() { # qr code scanner using zbar and scrot
    if command -v zbarimg &> /dev/null; then 
        scrot -l  mode=edge,style=dash,width=1,opacity=100 -s $HOME/.cache/qr.png
        local url=$(zbarimg --raw --quiet $HOME/.cache/qr.png)
        rm $HOME/.cache/qr.png
        if [ -n "$url" ]; then
            echo "QR-Code â¤µ\n$url"
            xdg-open "$url" &>/dev/null
        else
            echo "No QR code found"
        fi
    else
        sudo pacman -Sy --noconfirm zbar
        echo "Rerun to use"
        zsh
    fi

}

qrgen() { # qr code link generator
    if [ -z "$1" ]; then 
        echo "Usage: qrgen <text_or_url>" 
        return 1 
    fi  
    local input="$1" 
    local api_url="https://qrenco.de/$input"  
    curl -s $api_url || echo "Failed to generate QR Code."
}  

picom-toggle() { # Toggle picom
    if pgrep -x "picom" > /dev/null
    then
        killall picom
    else
        picom -b --config  $HOME/.config/picom/picom.conf
    fi
}

ytm-dl() { # Youtube music/playlist downloader in ./Music and also thumbnails depends from yt-dlp
    cd ~/Music
    if [ -z "$1" ]; then
      echo "Provide a YouTube link : "
      read -r link
    else
      link="$1"
    fi
    echo "Downloading audio with embedded thumbnail..."
    yt-dlp --embed-thumbnail --extract-audio --audio-format mp3 --ignore-config --yes-playlist --no-part --no-warnings -o "%(title)s.%(ext)s" "$link"
    echo "Done!"
}

cheat() { # Comunity driven cheatsheet for linux commands
    for arg in "$@"; do 
    if [[ ! "$@" = /* ]]; then  
        arg="/$@"  
    else  
        arg="$@"  
    fi  
    curl -sS cheat.sh$arg | clearcolors | highlight -S sh | bat --style=grid,header,snip --file-name "cheat.sh$arg"
    done
} 

inputpaste() { # simulating keybord input to type copied "force paste"
    [[ -z $1 ]] && lay="us"
    [[ ! -z $1 ]] && lay=$1
    LAYOUTOLD=$(setxkbmap -query | awk '/layout:/ {print $2}')
    setxkbmap $lay -option caps:none
    xdotool type "$(xclip -o)" && sleep 1
    trap "setxkbmap $LAYOUTOLD -option caps:none" 0
}

screenshot() { # make a screenshot
    if [[ $1 == "-h" || $1 == "--help" ]]; then
        echo -e "'crop' as \$1 to cut a part of the screen"
        return 0
    fi  
    if [ ! -d "$HOME/Pictures/Screenshots" ]; then
        mkdir -p "$HOME/Pictures/Screenshots"
    fi
    cd $HOME/Pictures/Screenshots
    if [[ $1 == "crop" ]]; then
        scrot -l  mode=edge,style=dash,width=1,opacity=100 -s 'Arch-%Y-%m-%d-%s_screencrop_$wx$h.jpg' -e 'notify-send 'Screenshot' $f && timeout 0.5 feh --title Preview --scale-down -s $f' 
    else
        scrot 'Arch-%Y-%m-%d-%s_screenshot_$wx$h.jpg' -e 'notify-send 'Screenshot' $f && timeout 0.5 feh --title Preview --scale-down -s $f' 
    fi
    LASTSCREENSHOT=$(ls -t1 | head -n 1)
    xclip -selection clipboard -t image/png -i $LASTSCREENSHOT 
}

record() { # FFmpeg video recorder
    if [[ $1 == "-h" || $1 == "--help" ]]; then
        echo -e "Usage: record [-a] <screen/webcam/audio> [<webcam-number>]\n-a: record audio"
        return 0
    fi
    timestamp=$(date "+%Y%m%d_%H%M%S")
    echo "Setup in pavucontrol the audio recording input."
    echo "Press Q to save and quit. Press Ctrl+C to only quit."
    if [ "$1" = "-a" ]; then
        recordaudio=1
        shift
    fi
    if [ "$1" = "audio" ]; then
        if pgrep -c xinit > /dev/null; then
            notify-send "Recording start" "in 5 seconds"
            sleep 5
        fi
        ffmpeg -y -f pulse -i default -c:a flac ~/Music/$timestamp.flac
    elif [ "$1" = "webcam" ]; then
        if pgrep -c xinit > /dev/null; then
            notify-send "Recording start" "in 5 seconds"
            sleep 5
        fi
        if [ -n "$2" ]; then
            recordwebcam="$2"
        else
            recordwebcam=0
        fi
        if [ -z "$recordaudio" ]; then
            ffmpeg -y -f v4l2 -i /dev/video$recordwebcam -preset ultrafast -qp 0 -y ~/Videos/$timestamp.mkv
        else
            ffmpeg -y -f v4l2 -i /dev/video$recordwebcam -f pulse -i default -c:v libx264 -c:a flac -preset ultrafast -qp 0 ~/Videos/$timestamp.mkv
        fi
    else
        if pgrep -c xinit > /dev/null; then
            notify-send "Pick region" "and drag"
        fi
        resolution=$(slop -f "%wx%h")
        if pgrep -c xinit > /dev/null; then
            notify-send "Recording start" "in 5 seconds"
            sleep 5
        fi
        if [ ! -z "$recordaudio" ]; then
            ffmpeg -y -f x11grab -s $resolution -i $DISPLAY -f pulse -i default -preset ultrafast -qp 0 ~/Videos/$timestamp.mkv
        else
            ffmpeg -y -f x11grab -s $resolution -i $DISPLAY ~/Videos/$timestamp.mkv
        fi
    fi
    if [ "$1" != "audio" ]; then
        if pgrep -c xinit > /dev/null; then
            notify-send "Recording finished" "Saved in ~/Videos/$timestamp.mkv"
        fi
    else
        if pgrep -c xinit > /dev/null; then
            notify-send "Recording finished" "Saved in ~/Music/$timestamp.flac"
        fi
    fi
}

videowal() { # Xorg root wallpaper video mpv and fzf to select Video in $HOME/Videos
    local videos=($(find "$HOME/Videos" -maxdepth 3 -type f -iregex '.*\.\(webm\|mp4\)' | sort ))
    if command -v xwrap &>/dev/null; then
    videos+=("Quit")
    else
    videos+=("Install")
    fi
    local selected_video=$(printf '%s\n' "${videos[@]}" | fzf-splitted)
    if [[ "$videos" == "Quit" ]]; then
        pkill -f "mpv"
    elif [[ "$videos" == "Install" ]]; then
        sudo pacman --noconfirm -S libx11
        cd $HOME/.local/share/bin/xwrap
        make
        sudo make install
        echo "Rerun to use."
        zsh
    else
        if command -v xwrap &>/dev/null; then
            pkill -f "mpv"
            nohup xwrap -o 1.0 -nf -ovr -- mpv -wid WID --loop-file=inf --video-unscaled --no-terminal --no-audio --no-input-default-bindings --no-border --no-window-dragging --no-osc --no-osd-bar "$selected_video" &
        fi
    fi
}

imagelistmd() { # cwd markdown images formatter
    output_file="IMAGES.md"
    image_files=$(find . -maxdepth 2 -type f \( -iname "*.jpg" -o -iname "*.jpeg" -o -iname "*.png" \))
    {
        echo "### Images"
        subdirs=()
        while IFS= read -r image_file; do
            subdir=$(dirname "$image_file")
            subdir="${subdir#./}" # Remove the "./" prefix
            if [[ ! " ${subdirs[@]} " =~ " ${subdir} " ]]; then
                subdirs+=("$subdir")
            fi
        done <<< "$image_files"
        for subdir in "${subdirs[@]}"; do
            echo "<details>"
            echo "<summary>$subdir</summary>"
            echo ""
            echo "<p>"
            find "$subdir" -maxdepth 1 -type f \( -iname "*.jpg" -o -iname "*.jpeg" -o -iname "*.png" \) -print0 | while IFS= read -r -d '' image_file; do
                filename=$(basename "$image_file")
                size=$(stat -c%s "$image_file")
                dimensions=$(identify -format "%wx%h" "$image_file")
                echo "<details>"
                echo "<summary>${filename%.*}</summary>"
                echo ""
                echo "<img src=\"$image_file\" alt=\"$filename\">"
                echo ""
                echo "<table>"
                echo "<tr><th>Size (bytes)</th><th>Dimensions (pixels)</th><th>Name</th></tr>"
                echo "<tr><td>$size</td><td>$dimensions</td><td>$filename</td></tr>"
                echo "</table>"
                echo ""
                echo "</details>"
            done
            echo "</p>"
            echo ""
            echo "</details>"
            echo ""
        done
    } > "$output_file"
    echo "Markdown file generated successfully at $output_file."
}

explain() { # universal explainer
    if ! pacman -Q ripgrep &> /dev/null; then
        sudo pacman -Sy --neded --noconfirm ripgrep
    fi
    local name=$1
    al="$HOME/.config/zsh/aliasrc"
    fn="$HOME/.config/zsh/funcrc"
    def=$(declare -f $name)
    if [[ -z "$1" ]]; then # if no argument prewiev zshconf
        highlight -S sh -i "$al" | bat --style=grid,header --file-name $al
        highlight -S sh -i "$fn" | bat --style=grid,header --file-name $fn
        return 1
    else    
        case "$(whence -w $name)" in
            *"alias"*)
                if [[ -n "$def" ]] ; then
                    echo $def | highlight -S sh | bat --style=grid,header,snip --file-name "$(type -a $name | sed '2!d' | cut -d " " -f 7)"
                fi
                alias="$(alias $name | sed "s/['\"]//g" | cut -d "=" -f 2)"
                if [[ "$(echo $alias | cut -d '|' -f 1 | cut -d ' ' -f 1)" == *"sudo"* ]]; then
                    namenext="$(echo $alias | cut -d '|' -f 1 | cut -d ' ' -f 2 )"
                else
                    namenext="$(echo $alias | cut -d '|' -f 1 | cut -d ' ' -f 1 )"         
                fi
                if [[ $namenext != $name ]]; then
                    if ! alias $namenext && command -v "$namenext" && ! type -a "$namenext" | cut -d ' ' -f 3 | grep -q "ELF";then
                        explain $namenext
                    fi
                fi
                if [[ "$(whence -w $namenext)" != *"builtin"* ]]&&[[ "$(alias $name | cut -d '|' -f 1 | cut -d ' ' -f 1)" != *"sudo"* ]]&&[[ "$(alias $name)" != *"|"* ]]; then
                    complexity="$(type -a $name | wc -l)"
                    type -a $name #| sed ''$complexity'!d'
                else
                    type -a $name #| sed '1!d'
                fi
                if [[ $namenext != $name ]] && [[ "$(alias $name)" == *"|"* ]]; then
                    explain "$(alias $name | sed "s/['\"]//g" | cut -d "=" -f 2 | cut -d '|' -f 2 | cut -d ' ' -f 2)"
                fi
                ;;
            *"command"*|*"builtin"*)
                file=$(type -a $name | head -n 1 | awk '{print $3}')
                file="$(realpath -q $file)"
                if [[ -n "$file" ]] && ! grep -q "ELF" $file  ; then
                    desc=$(sed -n '2{s/#[[:space:]]//g;p;}' "$file")
                    highlight -S sh -i $file  | bat --style=grid,header,snip --file-name "$file Comment: $desc"
                else
                    echo "$file"
                fi
                ;;
            *"function"*)
                desc=$(sed -n "/^[[:space:]]*$name() { #/{s/^[[:space:]]*$name() { #[[:space:]]*//;p;q;}" "$fn")
                if [[ -n "$def" ]]; then
                    echo $def | highlight -S sh | bat --style=grid,header,snip --file-name "$fn Comment: $desc"
                fi
                ;; 
            *)
                echo -e "$name not found"
                return 1
                ;;
        esac
    fi  
}

tts() { # Google TextToSpech
  local text="$1"
  if [[ -z $1 ]]; then
    echo "tts <text> <lang> <dir>"
    return 1   
  fi
  if [[ -z $2 ]]; then
    local lang="en"
  else
    local lang="$2"
  fi
  local encoded_text=$(echo "$text" | sed -e 's/ /+/g')
  local api_url="https://translate.google.com/translate_tts?ie=UTF-8&q=$encoded_text&tl=$lang&client=tw-ob"
  if [[ -z $3 ]]; then
    local temp_mp3_file
    temp_mp3_file=$(mktemp -t tts-XXXXXXXX.mp3)
  else
    local temp_mp3_file
    temp_mp3_file="$3"
  fi
  curl -o "$temp_mp3_file" "$api_url" NUL
  if pactl list modules | grep -q "virtual_mic" ;then
    paplay -d virtual_mic "$temp_mp3_file" NUL &!
  fi
  mpg123 "$temp_mp3_file" NUL
  if [[ -z $3 ]]; then
    rm "$temp_mp3_file" NUL
  fi
}

vmic() { # Virtual mic toggle
    if pactl list modules | grep -q "virtual_mic" ;then
        pactl unload-module module-remap-source NUL
        pactl unload-module module-null-sink NUL
        echo "VirtualMic unloaded."
    else
        pactl load-module module-null-sink sink_name=virtual_mic NUL
        pactl load-module module-remap-source master=virtual_mic.monitor source_name=virtual_mic NUL
        echo "VirtalMic loaded."
    fi
}

pacman-list() { # list system packages aur/pacman
    case "$1" in
        -p)
            pacman -Qen | bat --file-name "Pacman packages"
            o=$(pacman -Qen | wc -l)
            echo -e "Official : $o"
            d=$(pacman -Qd | wc -l)
            echo -e " Dependency : $d"
            ;;
        -a)
            pacman -Qem | bat --file-name "AUR packages"
            a=$(pacman -Qem | wc -l)
            echo -e "AUR : $a"
            ad=$(pacman -Qdm | wc -l)
            echo -e " Dependency : $ad"
            ;;
        -pa|-ap)
            pacman -Qe | bat --file-name "Aur/Pacman packages"
            all=$(pacman -Q | wc -l)
            echo -e "All : $all"
            d=$(pacman -Qd | wc -l)
            echo -e " Dependency : $d"
            o=$(pacman -Qen | wc -l)
            echo -e "Official : $o"
            ad=$(pacman -Qdm | wc -l)
            echo -e " Dependency : $ad"
            a=$(pacman -Qem | wc -l)
            echo -e "AUR : $a"
            od=$(pacman -Qdn | wc -l)
            echo -e " Dependency : $od"
            ;;
        -h|--help)
            echo "Usage: pacman-list [OPTION]"
            echo "Options:"
            echo "  -p         List official (pacman) packages"
            echo "  -a         List AUR packages"
            echo "  -pa        List both official and AUR packages"
            echo "  -h, --help Show this help message"
            ;;
        *)
            echo "Invalid option. Use '-h' or '--help' for more information."
            ;;
    esac
}

pacman-log() { # pacman logs like history of installed
    local usage="Usage: pacman-log [OPTIONS]\n Options:
    -i, --install    Show only install logs.
    -r, --remove     Show only remove logs.
    -m               Show in inverted order.
    -h, --help       Display this help message."
    local log_file="/var/log/pacman.log"
    local install_logs=""
    local remove_logs=""
    local order_logs=""
    if [[ ! -f "$log_file" ]]; then
        echo "Error: pacman.log file not found at /var/log/pacman.log"
        return 1
    fi
    while (( $# > 0 )); do
        case "$1" in
        -m) order_logs="true" ;;
        -i|--install) install_logs="installed" ;;
        -r|--remove) remove_logs="removed" ;;
        -ri) install_logs="installed" ; remove_logs="removed" ;;
        -rim) install_logs="installed" ; remove_logs="removed" ; order_logs="true" ;;
        -rm|-mr) install_logs="installed" ; remove_logs="removed" ; order_logs="true" ;;
        -im|-mi) install_logs="installed" ; remove_logs="removed" ; order_logs="true" ;;
        -h|--help)
            echo -e "$usage"
            return 0
            ;;
        *)
            echo "Error: Unknown option: $1"
            echo -e "$usage"
            return 1
            ;;
        esac
        shift
    done
    local log_filter=""
    if [[ -n "$install_logs" && -n "$remove_logs" ]]; then
        log_filter="grep -E '\\[(PACMAN|ALPM)\\] (installed|removed)' \"$log_file\""
    elif [[ -n "$install_logs" ]]; then
        log_filter="grep -E '\\[(PACMAN|ALPM)\\] (installed)' \"$log_file\""
    elif [[ -n "$remove_logs" ]]; then
        log_filter="grep -E '\\[(PACMAN|ALPM)\\] (removed)' \"$log_file\""
    else
        echo -e "$usage"
        return 1
    fi
    local final_cmd="$log_filter | highlight -S sh"
    if [[ -n "$order_logs" ]]; then
        final_cmd+=" | tac"
    fi
    eval "$final_cmd | bat --plain"
}

gpush() { # Git Push Utils
    if [[ -z $1 ]] ; then
        git add .
        git commit -m "update"
    else
        git add .
        git commit -m "$1"
    fi
    if [[ -z $2 ]]; then
        git push -f origin main
    else
        git push -f origin "$2" 
    fi
}

ginit() { # Git Init Utils
  command -v gh >/dev/null 2>&1 || { echo >&2 "The 'gh' command is required. Please install it before running this function."; return 1; }
  command -v git >/dev/null 2>&1 || { echo >&2 "The 'git' command is required. Please install it before running this function."; return 1; }
  if [ -z "$1" ]; then
    echo "Please provide a repository name as an argument."
    return 1
  fi
  local commit_message="Init"
  local branch_name="main"
  if [ "$(du -sb . | cut -f1)" -gt $((2*1024*1024*1024)) ]; then
    echo "The directory size exceeds 2 GB. Aborting."
    return 1
  fi
  echo "Creating repository $1 on GitHub..."
  gh repo create "$1" --public
  echo "Initializing local Git repository..."
  git init
  echo "Adding all files to the staging area..."
  git add .
  echo "Committing changes..."
  git commit -m "$commit_message"
  echo "Renaming default branch to $branch_name..."
  git branch -M "$branch_name"
  echo "Setting remote origin to GitHub repository..."
  git remote add origin "https://github.com/$(gh api user | jq ".login" | tr -d '"')/$1.git"
  echo "Pushing changes to remote repository..."
  git push -u origin "$branch_name"
  echo "Done!"
}

greset() { # Git Squash all in 1 commit
    if [[ -z $1 ]]; then
        commit="Init"
    else
        commit="$1"
    fi
    tree=$(git write-tree)
    commit=$(echo "$commit" | git commit-tree $tree)
    git reset --hard $commit
    git push origin main --force
}

gclone() { # Git Clone And Cd
    if [[ -z $1 ]]; then
        echo -n "Repo? --> "
        read clonedir 
    else
        clonedir=$1
    fi
    git clone "$clonedir"
    cd "$(basename "$clonedir" .git)"
}

g() { # Universal Git
    state=$(echo -e "Clone\nReset\nPull\nPush\nInit" | fzf-splitted )
    case $state in
        "Clone") gclone "$1" ;;
        "Reset") greset "$1" ;;
        "Pull") git pull ;;
        "Push") gpush "$1" ;;
        "Init") ginit ;;
        *)  echo "'$1' is not a valid option" ;;
    esac
}

ex() { # Universal archive extractor
    if [ -f $1 ] ; then
        case $1 in
        *.tar.bz2)   tar xjf $1   ;;
        *.tar.gz)    tar xzf $1   ;;
        *.tar.xz)    tar xJf $1   ;;
        *.bz2)       bunzip2 $1   ;;
        *.rar)       unrar x $1   ;;
        *.gz)        gunzip $1    ;;
        *.tar)       tar xf $1    ;;
        *.tbz2)      tar xjf $1   ;;
        *.tgz)       tar xzf $1   ;;
        *.zip)       unzip $1     ;;
        *.Z)         uncompress $1;;
        *.7z)        7z x $1      ;;
        *)           echo "'$1' cannot be extracted via ex()" ;;
        esac
    else
        echo "'$1' is not a valid file"
    fi
}

render() { # Render images in the terminal
    display_info=false
    if [[ $# -eq 0 ]]; then
        echo "Usage: render [-i | --info],[-b] <image_file1> <image_file2> ..."
        return 1
    fi
    if [[ $1 == "-i" ]] || [[ $1 == "--info" ]]; then
        display_info=true
        shift
    fi
    for image_file in "$@"; do
        local image_file=$(realpath $image_file 2>/dev/null)
        if $display_info; then
            file_size_bytes=$(du -b "$image_file" | cut -f1)
            file_size_kb=$((file_size_bytes / 1024))
            dimensions=$(identify -format "%wx%h" "$image_file" 2>/dev/null)
            echo "\033[1;36m$image_file \033[1;33m[$file_size_kb KB]\033[1;32m [$dimensions]\033[0m"
        fi
        if [[ $KITTY_WINDOW_ID ]]; then
            if [[ $1 == "-b" ]]; then
                kitty @ --to $KITTY_LISTEN_ON set-background-image "$image_file" 2>/dev/null
            else
                icat "$image_file"
            fi
        elif tty -s; then
            chafa --stretch -C on $image_file
        else
            echo '{"action": "add", "x": 0, "y": 0, "identifier": "test", "path": "'"$image_file"'"}' | ueberzug layer --parser json
        fi
    done
    if [[ ! -f "$image_file" ]]; then
        echo "Error: File '$image_file' not found."
        return 1
    fi
}

xcopy() { # copy dirs/files to paste in other dir
  local display_list=false
  local clear_list=false
  while getopts ":lch" opt; do
    case $opt in
      l)
        display_list=true
        ;;
      c)
        clear_list=true
        ;;
      h)
        echo "Usage: copy [-l] [-c] [files/directories...]"
        echo "Options:"
        echo "  -l    Display the list of previously copied items"
        echo "  -c    Clear the list of copied items"
        echo "  -h    Show this help message"
        return 0
        ;;
      ?)
        echo "Invalid option: -$OPTARG"
        return 1
        ;;
    esac
  done
  shift $((OPTIND -1))
  if $display_list; then
    if [[ ${#copied[@]} -eq 0 ]]; then
      echo "No items have been copied yet."
    else
      echo "Previously copied items:"
      printf '%s\n' "${copied[@]}"
    fi
    return 0
  fi
  if $clear_list; then
    copied=()
    echo "Cleared the list of copied items."
    return 0
  fi
  if [[ $# -eq 0 ]]; then
    local selected_items=$(ls -A | fzf-splitted --multi)
    if [[ -n $selected_items ]]; then
      while IFS= read -r item; do
        local source=$(realpath "$item")
        if [[ -e $source ]]; then
          copied+=("$source")
          echo "Copied: $source"
          echo -n "$source" | xclip -selection clipboard
        else
          echo "The specified path does not exist: $source"
        fi
      done <<< "$selected_items"
    fi
    return 0
  fi
  while [[ $# -gt 0 ]]; do
    local source=$(realpath "$1")
    if [[ ! -e $source ]]; then
      echo "The specified path does not exist: $source"
    else
      copied+=("$source")
      echo "Copied: $source"
      echo -n "$source" | xclip -selection clipboard
    fi
    shift
  done
}

xpaste() { # paste copied dirs/files in other dir
  local destination=$PWD
  local move=false
  if ! command -v fzf &> /dev/null; then
    echo "fzf is required but not installed. Aborting."
    return 1
  fi
  while getopts ":mhd:" opt; do
    case $opt in
      m)
        move=true
        ;;
      h)
        echo "Usage: paste [-m] [-h] [-d destination_directory]"
        echo "Options:"
        echo "  -m    Move (cut) the copied items instead of copying"
        echo "  -h    Show this help message"
        echo "  -d    Specify the destination directory"
        return 0
        ;;
      d)
        destination="$OPTARG"
        ;;
      ?)
        echo "Invalid option: -$OPTARG"
        return 1
        ;;
    esac
  done
  shift $((OPTIND -1))
  if [[ ${#copied[@]} -eq 0 ]]; then
    echo "No items have been copied yet."
    return 1
  fi
  selected_items=$(printf "%s\n" "${copied[@]}" | fzf-splitted --multi)
  if [[ -z "$selected_items" ]]; then
    echo "No items selected. Aborting."
    return 1
  fi
  if [[ $# -gt 0 ]]; then
    destination="$1"
    shift
  fi
  if [[ ! -d $destination ]]; then
    echo "The destination path is not a valid directory: $destination"
    return 1
  fi
  while read -r item; do
    if $move; then
      if [[ -e $item ]]; then
        mv -f "$item" "$destination" 2>/dev/null
        echo "Moved: $item to $destination"
      fi
    else
      if [[ -e $item ]]; then
        cp -rf "$(realpath "$item")" "$destination" 2>/dev/null
        echo "Copied: $item to $destination"
      fi
    fi
    copied=("${copied[@]/$item}")
  done <<< "$selected_items"
}

setkeymap() { # set keyboard layout 
    ttywal
    if [[ -n $DISPLAY ]]; then
        sudo localectl set-x11-keymap --no-ask-password $1
        sudo setxkbmap $1
    else
        sudo loadkeys $1
    fi
}

xev-input() { # Input in a readable way
    xev | awk -F'[ )]+' '/^KeyPress/ { a[NR+2] } NR in a { printf "%-3s %s\n", $5, $8 }'
}

bookmarks() { # Bookmarks menu select marks
    CacheFile="${XDG_CACHE_HOME:-$HOME/.cache}/bookmarks.cache"
    current_user=$(whoami)
    sed -i "s|\$HOME|/home/$(whoami)|g" "$HOME/.cache/bookmarks.cache"
    selected=$(sed "s|^$HOME|/home/$current_user|g" "$CacheFile" | fzf-splitted)
    if [ -n "$selected" ]; then
        if [ -d "$selected" ]; then
            cd "$selected" || exit 1
        else
            xdg-open "$selected"
        fi
    fi
}

bookmark() { # make dir/file marked
    CacheFile="${XDG_CACHE_HOME:-$HOME/.cache}/bookmarks.cache"
    local path
    if [ -z "$@" ]; then
        path=$(pwd)
    else
        path=$1
    fi
    if [ -e "$path" ]; then
        echo -e "$path\n" >> "$CacheFile"
        echo "Added '$path' to bookmarks."
    else
        echo "Error: '$path' does not exist."
    fi
}

cpbin() { # Copy binaries with deps in a folder
    if [[ "$#" -ne 2 ]]; then
        echo "Usage: cpbin <command> <path>"
        return 1
    fi
    local target_path="$2"
    local program=$(type -a "$1" | grep -o '/[^ ]*$')
    copy_to() {
        local source="$1"
        local destination="$2"
        sudo mkdir -p "$destination"
        echo "Coping $source to $destination"
        sudo cp "$source" "$destination"
    }
    copy_to "$program" "$target_path/bin"
    copy_to "$program" "$target_path/usr/bin"
    echo "Finding and moving dependencies of $program..."
    while IFS= read -r dep; do
        local destination="$target_path$(dirname "$dep")"
        copy_to "$dep" "$destination"
    done < <(ldd "$program" | awk '/=>/{print $(NF-1)}')
    sudo cp -r "$target_path/usr/lib" "$target_path/lib"
    sudo cp -r "$target_path/usr/lib64" "$target_path/lib64"
    echo "Coping operation completed successfully."
    echo -e "You can chroot in it with \"sudo chroot "$target_path"\""
}

conf() { # config folder cd
    local x="$HOME/.config"
    local path="$x/$@"
    if [ -d "$path" ]; then
        cd "$path"
    else
        echo "Path does not exist: $path"
        return 1
    fi
}

ssh-server() { # Toggle a sshd server in port 22
    serv="sshd.service"
    state=$(sudo systemctl is-enabled $serv)
    if [[ $state == "disabled" ]]; then 
        sudo systemctl enable $serv
        sudo systemctl start $serv
    else
        sudo systemctl stop $serv
        sudo systemctl disable $serv
    fi
}

ttyfont() { # TTY font selector
    if [ -z $1 ]; then
        ttywal -f
        fonts=($(ls /usr/share/kbd/consolefonts/))
        selected_font=$(echo "${fonts[@]}" | tr ' ' '\n' | fzf)
    else
        selected_font=$1
    fi
    envrc_file="$HOME/.config/zsh/envrc"
    selected_font="${selected_font%%.*}"
    if grep -q "export TTYFONT=" "$envrc_file"; then
        sed -i "/export TTYFONT=/c\export TTYFONT=\"$selected_font\"" "$envrc_file"
    else
        echo "export TTYFONT=\"$selected_font\"" >> "$envrc_file"
    fi
    if [ -n "$selected_font" ]; then
        if grep -q "FONT=" /etc/vconsole.conf; then
            sed -i "/^FONT=/d" /etc/vconsole.conf
        fi
        echo "FONT=$selected_font" | tee -a /etc/vconsole.conf > /dev/null 2>&1
        setfont /usr/share/kbd/consolefonts/$selected_font > /dev/null 2>&1
        #echo "Console font set to: $selected_font"
    else
        echo "No font selected."
    fi
    keymap=$(localectl status | grep "Layout" | awk '{print $3}')
    echo -e "KEYMAP=$keymap\nXKBLAYOUT=$keymap\nXKBMODEL=pc105\nXKBOPTIONS=terminate:ctrl_alt_bksp" | tee -a /etc/vconsole.conf > /dev/null
    if [ -z $1 ]; then
        sudo mkinitcpio -p linux
    fi
}

tag() { # Use ffmpeg to set tag of files
err() {
echo "Usage:
    tag [OPTIONS] file
Options:
    -a: artist/author
    -t: song/chapter title
    -A: album/book title
    -n: track/chapter number
    -N: total number of tracks/chapters
    -d: year of publication
    -g: genre
    -c: comment
You will be prompted for title, artist, album, and track if not given." && return 1 ;
}
    while getopts "a:t:A:n:N:d:g:c:" o; do
        case "${o}" in
            a) artist="${OPTARG}" ;;
            t) title="${OPTARG}" ;;
            A) album="${OPTARG}" ;;
            n) track="${OPTARG}" ;;
            N) total="${OPTARG}" ;;
            d) date="${OPTARG}" ;;
            g) genre="${OPTARG}" ;;
            c) comment="${OPTARG}" ;;
            *) printf "Invalid option: -%s\\n" "$OPTARG" && err ;;
        esac
    done
    shift $((OPTIND - 1))
    file="$1"
    temp="$(mktemp -p "$(dirname "$file")")"
    trap 'rm -f $temp' HUP INT QUIT TERM PWR EXIT
    [ ! -f "$file" ] && echo 'Provide file to tag.' && err
    [ -z "$title" ] && echo 'Enter a title.' && read -r title
    [ -z "$artist" ] && echo 'Enter an artist.' && read -r artist
    [ -z "$album" ] && echo 'Enter an album.' && read -r album
    [ -z "$track" ] && echo 'Enter a track number.' && read -r track
    cp -f "$file" "$temp" && ffmpeg -i "$temp" -map 0 -y -codec copy \
	-metadata title="$title" \
	-metadata album="$album" \
	-metadata artist="$artist" \
	-metadata track="${track}${total:+/"$total"}" \
	${date:+-metadata date="$date"} \
	${genre:+-metadata genre="$genre"} \
	${comment:+-metadata comment="$comment"} "$file"
}

# Images

imagerotate() { # Imagemagick image rotate
    local image_file="$1"
    local rotate_degree=0
    local rotate_step=90
    local temp_file="$image_file-temp"
    local base_name="${image_file%.*}"
    local extension="${image_file##*.}"
    cp "$image_file" "$temp_file"
    while true; do
        render "$temp_file"
        echo "Use '+' to increase hue, '-' to decrease hue."
        echo "Press 'Enter' or 'q' to save and exit."
        read -rsk1 input
        if [[ "$input" == "+" ]]; then
            ((rotate_degree += rotate_step))
            convert "$temp_file" -rotate $rotate_step "$temp_file"
        elif [[ "$input" == "-" ]]; then
            ((rotate_degree -= rotate_step))
            convert "$temp_file" -rotate -$rotate_step "$temp_file"
        elif [[ "$input" == "q" || "$input" == $'\e' ]]; then
            cp "$temp_file" "$base_name-degree${rotate_degree}.$extension"
            break
        fi
    done
    rm -vI -f "$temp_file"
}

imagehue() { # Imagemagick image hue shifter
    local image_file="$1"
    local hue_shift=0
    local hue_step=5
    local temp_file="temp_$image_file"
    local base_name="${image_file%.*}"
    local extension="${image_file##*.}"
    while true; do
        convert "$image_file" -modulate 100,100,$((100 + hue_shift)) "$temp_file"
        render "$temp_file"
        echo "Use '+' to increase hue, '-' to decrease hue."
        echo "Press 'Enter' or 'q' to save and exit."
        read -rsk1 input
        case "$input" in
            "+") ((hue_shift += hue_step)) ;;
            "-") ((hue_shift -= hue_step)) ;;
            $'\n' | "q" | $'\e') cp "$temp_file" "$base_name-hue${hue_shift}.$extension"; break ;;
        esac
    done
    rm "$temp_file"
}

imageresize() { # Imagemagick image resize
    if [ $# -ne 3 ]; then
        echo "Usage: xresize <input-file> <width> <height>"
        return 1
    fi
    local input_file="$1"
    local width="$2"
    local height="$3"
    local file_extension="${input_file##*.}"
    local output_file="${input_file%.*}${width}x${height}.${file_extension}"
    local lowercase_file_extension="$(echo "$file_extension" | tr '[:upper:]' '[:lower:]')"
    if [[ "${lowercase_file_extension}" =~ ^(jpg|jpeg|png)$ ]]; then
        convert "${input_file}" -resize "${width}x${height}" "${output_file}"
        echo "Resized ${input_file} to ${output_file}"
    else
        echo "Invalid file extension. Supported formats: jpg, jpeg, png"
        return 1
    fi
}

gh-clone() { # GitHub Private Repository Clone
    if [[ $# -ne 2 ]]; then
        echo "Usage: gh-git <username> <repository>"
        echo "Example: gh-git exampleuser example-repo"
    else
        git clone "git@github.com:$1/$2"
    fi
}

# Extra

if command -v newsboat &>/dev/null; then

if ! command -v urlscan &>/dev/null; then
    sudo pacman -Sy --noconfirm urlscan
fi

rssadd() { # Add rss feeds to newsboat
    if echo "$1" | grep -q "https*://\S\+\.[A-Za-z]\+\S*" ; then
        url="$1"
    else
        url="$(grep -Eom1 '<[^>]+(rel="self"|application/[a-z]+\+xml)[^>]+>' "$1" | grep -o "https?://[^\" ]")"
        echo "$url" | grep -q "https*://\S\+\.[A-Za-z]\+\S*" || notify-send "That doesn't look like a full URL." && exit 1
    fi
    RSSFILE="${XDG_CONFIG_HOME:-$HOME/.config}/newsboat/urls"
    if awk '{print $1}' "$RSSFILE" | grep "^$url$" >/dev/null; then
        notify-send "You already have this RSS feed."
    else
        echo "$url" >> "$RSSFILE" && notify-send "RSS feed added."
    fi
}

fi

# Thinkering

udev-fix() { # Fix serial ports to have read/write permissions on usb connection
    UDEV_RULES_PATH="/etc/udev/rules.d/50-ttyusb.rules"
    if [ ! -f "$UDEV_RULES_PATH" ]; then
        UDEV_RULE1='KERNEL=="ttyUSB*", MODE="0666"'
        UDEV_RULE2='KERNEL=="ttyACM*", MODE="0666"'
        sudo bash -c "echo '$UDEV_RULE1' > '$UDEV_RULES_PATH'"
        sudo bash -c "echo '$UDEV_RULE2' >> '$UDEV_RULES_PATH'"
        sudo udevadm control --reload-rules
        sudo udevadm trigger
        echo "Udev rules created and reloaded."
    fi
}

arduino-flash() { # Avr boards flasher
    if ! command -v arduino &>/dev/null; then
        if ! command -v yay &>/dev/null; then
            yay arduino-ide-src
        else
            sudo pacman -Sy arduino
        fi
        udev-fix
        if ! command -v arduino-cli &>/dev/null; then
            sudo pacman -Sy arduino-cli || return 1
        fi
    fi
    local input=$(arduino-cli board search | sed '1d' | fzf-splitted --prompt='Select Board > ' | awk '{print $(NF-1)}')
    if [[ ! -f "./*.ino"  ]]; then
        if [[ ! -z "$1" ]]; then
            local project="$1"
        else
            local project=$(echo -e "[Examples]\n$(find $HOME/Arduino/ -type d -not -path "$HOME/Arduino/libraries*" -not -path "$HOME/Arduino/")" | fzf-splitted --prompt='Select Sketch > ')
            if [[ "$project" == "[Examples]" ]]; then
                project=$(find $HOME/.arduino15/packages/ -type f -iregex '.*\.ino' -o -path "$HOME/Arduino/libraries/*" -type f -iregex '.*\.ino' | fzf --prompt='Select Example > ' --preview-window=up:80% --preview "fzf-preview {}")
            fi
        fi
    fi
    serial_ports=($(find /dev -type c \( -name 'ttyUSB*' -o -name 'ttyACM*' \)))
    if [[ ${#serial_ports[@]} -eq 1 ]]; then
        serial_port="-p ${serial_ports[@]} "
    elif [[ ${#serial_ports[@]} -gt 1 ]]; then
        chosen_port=$(printf "%s\n" "${serial_ports[@]}" | fzf-splitted --prompt='Select Serial Port > ')
        serial_port="-p $chosen_port"
    fi
    zsh -ci "arduino-cli compile $project $serial_port -b $input"
    zsh -ci "arduino-cli upload $project $serial_port -b $input"
}

adb-shell() { # adb shell connection 
    if ! command -v adb &>/dev/null; then
        if ! command -v yay &>/dev/null; then
            echo "yay not installed"
        fi
        yay -S --noconfirm adb-sync-git || return 1
    fi
    if [ "$1" ]; then
        adb connect "$1"
        adb -s "$1" shell
        adb disconnect "$1"
    else
        devices=$(adb devices | awk '/device$/{print $1}')
        if [ -z "$devices" ]; then
            echo "No devices found."
            return 1
        fi
        for device in $devices; do
            adb -s "$device" shell
        done
    fi
}

writemem() { # Command to write in memory address
    if ! command -v writemem-server &>/dev/null; then
        cd $HOME/.local/share/bin/writemem-server
        make install
        exit
    fi
    if [ "$#" -ne 4 ]; then
        echo "Usage: writemem <pid> <datatype> <address> <value>"
        return 1
    fi
    echo "$1 $2 $3 $4" > ~/.cache/writemem
}

blackarch() { # blackarch tools installer and repo
    if pacman -Qi blackarch-keyring &>/dev/null; then
        echo "BlackArch keyring is already installed."
    else
        echo "Installing BlackArch Repository..."
        curl -O https://blackarch.org/strap.sh && {
        chmod +x strap.sh
        sudo ./strap.sh && echo "Repository installed."
        rm strap.sh
        } || {
        echo "Failed to install the repository."
        return 1
        }
    fi
  case $(echo -e "Browse\nExit" | fzf-splitted --prompt "Select an option: ") in
    "Browse")
        while true; do
            local category=$(pacman -Sg | grep blackarch | fzf-splitted --header "Choose a category or 'Exit' to go back:" --exit-0)
            if [[ -n $category && $category != "Exit" ]]; then
            local submenu=$(echo -e "Install All $category\nList Tools\nGo Back" | fzf-splitted --prompt "You are in category '$category'. Choose an action: ")
            case "$submenu" in
                "Install All $category")
                sudo pacman -S "$category"
                ;;
                "List Tools")
                local tool=$(pacman -Sg $category | awk '{print $2}' | fzf-splitted --prompt "Select a tool to install or 'Exit' to go back: ")
                if [[ -n $tool && $tool != "Exit" ]]; then
                    echo "Installing $tool..."
                    sudo pacman -S "$tool"
                fi
                ;;
                "Go Back")
                break
                ;;
                *)
                echo "Invalid option."
                ;;
            esac
            else
            break
            fi
        done
      ;;
    "Exit")
      echo "Exiting BlackArch utility."
      ;;
    *)
      echo "No valid option selected."
      ;;
  esac
}

serial() { # Serial usb reader
    if ! [[ "$1" == "--help" || "$1" == "-h" ]]; then
        if ! command -v screen &>/dev/null; then
            sudo pacman -Sy screen || return 1
        fi
        local baud_rates=("300" "1200" "2400" "4800" "9600" "14400" "19200" "38400" "57600" "115200" "230400" "460800" "921600")
        serial_ports=($(find /dev -type c \( -name 'ttyUSB*' -o -name 'ttyACM*' \)))
        if [[ ${#serial_ports[@]} -eq 1 ]]; then
            serial_port="${serial_ports[@]}"
            echo "Connecting to > ${serial_ports[@]}"
        elif [[ ${#serial_ports[@]} -gt 1 ]]; then
            chosen_port=$(printf "%s\n" "${serial_ports[@]}" | fzf-splitted --prompt='Select Serial Port > ')
            serial_port="$chosen_port"
        else
            echo "Serial not found. Aborting."
            return 1
        fi
        local baud_rate=$(printf "%s\n" "${baud_rates[@]}" | fzf-splitted --prompt='Select Baud Rate > ')
        if [[ -z $serial_port || ! -e "$serial_port" || -z $baud_rate ]]; then
            echo "Invalid selection. Aborting."
            return 1
        fi
        sudo chmod a+rw $serial_port
        udev-fix
        if [ "$1" != "-a" ]; then
            sudo screen "$serial_port" "$baud_rate" $1
            sudo killall screen 2>/dev/null
        else
            arduino-cli monitor -p "$serial_port" -l serial -c baudrate="$baud_rate" --raw -q $2
        fi        
        echo "Serial communication ended."
    else
        echo -e "-a = to use arduino monitor"
        if [ "$2" != "-a" ]; then
            screen -h
        else
            arduino-cli monitor --help
        fi
    fi
}

# Zsh 

nyack() { # command not found handler Dependency from "fzf,thefuck"
    echo "Command $1 not found. Do you want to install $1?"
    local options=("Install" "Skip" "Fix")
    local install_choice=$(printf '%s\n' "${options[@]}" | fzf-splitted)
    if [[ "$install_choice" == "Skip" ]]; then
        echo "Command not installed. Skipping execution."
        return 1
    elif [[ "$install_choice" == "Fuck" ]]; then
        echo "Using 'fuck' to correct your typo..."
        fuck
        return $?
    elif [[ "$install_choice" == "Install" ]]; then
        echo -e "Using 'instance' to execute the command in an instance ...\nctrl+c to quit without uninstalling"
        if yay -S "$1"; then
            echo "Command $1 has been installed." && pacman -Qi "$1" | grep -v 'None'
            "$@"
            local exit_code=$?
            if yay -Rns "$1"; then
                echo "Command $1 has been uninstalled after running in instance mode."
            else
                echo "Uninstallation after instance mode failed. Please check if the package is still available."
            fi
            return $exit_code
        else
            echo "Installation failed. Please check if the package is available."
            return 1
        fi
    else
        return 0
    fi 
}

plugins() { # $HOME/.config/zsh/plugins scan of .zsh plugins and source in zshrc
    local plugins_dir="$HOME/.config/zsh/Plugins"
    local available_plugins=("$plugins_dir"/*.zsh(N^/)) ##local available_plugins=("$plugins_dir"/*.zsh(N))##also subfolders
    local active_plugins=()
    while read -r line; do
        if [[ $line == "source $plugins_dir/"* ]]; then
        local plugin_name="${line##*/}"
        plugin_name="${plugin_name%.zsh}"
        active_plugins+=("$plugin_name (enabled)")
        fi
    done < "$HOME/.config/zsh/.zshrc"
    for plugin_file in "${available_plugins[@]}"; do
        local plugin_name="${plugin_file##*/}"
        plugin_name="${plugin_name%.zsh}"
        if ! printf '%s\n' "${active_plugins[@]}" | grep -q "^$plugin_name"; then
        active_plugins+=("$plugin_name (disabled)")
        fi
    done
    local selected_plugins=$(printf '%s\n' "${active_plugins[@]}" | fzf-splitted)
    if [[ -n "$selected_plugins" ]]; then
        printf '%s\n' "$selected_plugins" | while read -r plugin_str; do
        local plugin_name="${plugin_str%% *}"
        if [[ $plugin_str == *"(disabled)" ]]; then
            echo "source $plugins_dir/$plugin_name.zsh" >> "$HOME/.config/zsh/.zshrc"
        else
            grep -v "source $plugins_dir/$plugin_name.zsh" "$HOME/.config/zsh/.zshrc" > "$HOME/.config/zsh/.zshrc.tmp" && mv -f "$HOME/.config/zsh/.zshrc.tmp" "$HOME/.config/zsh/.zshrc"
        fi
        done
        clear
        exec zsh
    fi
}

# Alias replaced

manx() { # make man displays also infopages
    command="$1"
    if [[ -z "$2" && "$1" != "-h" && "$1" != "--help" ]]; then
        \man "$@"
        if \info -w "$@" 2>/dev/null; then
            info "$@"
        fi 
    else
        \man "$@"
    fi
}

lfx() { # makes lf enter in the current dir on enter
    local last_dir_path=~/.last_lf_dir
    \lf -last-dir-path="$last_dir_path" "$@"
    [ -f "$last_dir_path" ] && export lastlfdir="$(cat "$last_dir_path")" && cd "$lastlfdir" && rm "$last_dir_path"
}

# Systemd 

autologin() { # Toggle systemd autologin for the currend user in tty1
    if [[ "$1" == "info" ]]; then
        local tty_number="1"
        local service_file="/etc/systemd/system/getty@tty${tty_number}.service.d/autologin.conf"
        if [[ -f "$service_file" ]]; then
            echo "Auto-login enabled"
        else
            echo "Auto-login disabled"
        fi
    else
        local tty_number="1"
        local service_dir="/etc/systemd/system/getty@tty${tty_number}.service.d"
        local service_file="$service_dir/autologin.conf"
        local current_user=$(whoami)
        if [[ -f "$service_file" ]]; then
            sudo rm "$service_file" && \
            sudo systemctl daemon-reload && \
            echo "Auto-login disabled for tty${tty_number}"
        else
            if [[ ! -d "$service_dir" ]]; then
                sudo mkdir -p "$service_dir"
            fi
            echo -e "[Service]\nExecStart=\nExecStart=-/sbin/agetty --autologin $current_user --noclear %I \$TERM" | sudo tee "$service_file" > /dev/null
            sudo systemctl daemon-reload && \
            echo "Auto-login enabled for tty${tty_number} with user $current_user"
        fi
    fi
}

logintty () { # Switch user only if autologin is disabled
    local tty_number="1" 
    local service_dir="/etc/systemd/system/getty@tty${tty_number}.service.d" 
    local service_file="$service_dir/autologin.conf" 
    local current_user=$(whoami) 
    if [[ -f "$service_file" ]]; then
        notify-send "disable Auto-login for tty${tty_number} to continue"
    else
        loginctl kill-session $XDG_SESSION_ID
    fi
}

# Xorg

setwm() { # Xorg initrc sed last line "exec" to be "exec '$WM'"
    program_name="$1"
    if [[ -z $2 ]]; then
        xinitrc_file="/etc/X11/xinit/xinitrc"
    else
        xinitrc_file="$2"
        if [[ ! -f "$xinitrc_file" ]]; then
            cp -f /etc/X11/xinit/xinitrc "$xinitrc_file"
        fi
    fi
    sudo sed -i 's/.*\(exec\).*/\1/' "$xinitrc_file"
    sudo sed -i '/^while true; do$/d;/^done$/d' "$xinitrc_file"
    if [[ $program_name == "dwm" ]]; then
        if sudo sed -i "\$s|^exec.*|while true; do\n  $program_name 2> ~/.cache/.dwm.log # exec\ndone|" "$xinitrc_file"; then
            echo "Loop logic added and last 'exec' line updated to run $program_name in $xinitrc_file"
        else
            echo "Failed to update $program_name in $xinitrc_file"
        fi
    else
        if sudo sed -i "\$s|^exec.*|exec $program_name|" "$xinitrc_file"; then
            echo "Last 'exec' line updated to run $program_name in $xinitrc_file"
        else
            echo "No 'exec' line found in $xinitrc_file"
        fi
    fi
}

start() { # Simply makes you can start X with start $WM like "start awesome"
    if [[ $1 == "-h" ]]; then
        echo -e "example-> start <wm>\n -t = temporary set wm \"not persistent\""
        return 0
    elif [[ -z $1 ]]; then
        if cat /etc/X11/xinit/xinitrc | grep 'exec hyperland' ; then
            Hyprland
        else
            startx
        fi
    else
        if [[ $1 == "term" ]]; then
            startx /etc/X11/xinit/xinitrcterm
        else
            if [[ $2 == "-t" ]]; then
                if [[ $1 == "hyperland" ]]; then
                    Hyprland
                else
                    [[ ! -f "$HOME/.local/xinit/" ]] && mkdir -p "$HOME/.local/xinit/"
                    tmpinitrc="$HOME/.local/xinit/xinitrc$1"
                    setwm "$1" "$tmpinitrc"
                    startx "$tmpinitrc"
                fi
            else
                if [[ $1 == "hyperland" ]]; then
                    setwm "$1"
                    Hyprland
                else
                    setwm "$1"
                    startx
                fi
            fi
        fi
    fi
}

xrandr-set() { # Xrandr permanent set for X in etc/X11/xinit/xinitrc
    arg=$1
    if [ -z "$arg" ]; then
        echo -n 'Screen size XxY: '
        read screensize
        echo -n 'Refresh rate (Hz): '
        read refresh_rate
        display=$(xrandr | awk '/ connected/ {print $1; exit}')
        sudo sed -i "/xrandr/c\xrandr --output $display --primary --mode $screensize --rate $refresh_rate --pos 0x0 --rotate normal" "/etc/X11/xinit/xinitrc"
        xrandr --output $display --primary --mode $screensize --rate $refresh_rate --pos 0x0 --rotate normal
    else
        $arg+=""
        sudo sed -i "/xrandr/c\xrandr $arg" "/etc/X11/xinit/xinitrc"
    fi
}

# Awesome

awesome-theme() { # Search in ~/.config/awesome/themes for themes and set "local chosen_theme ="$THEME"" in ~/.config/awesome/rc.lua
    local themes=($(ls ~/.config/awesome/themes))
    local chosen_theme=$(awk -F '"' '/ theme =/ {print $2}' ~/.config/awesome/rc.lua)
    local theme=$(printf '%s\n' "${themes[@]}" | grep -vx "$chosen_theme" | fzf-splitted)
    if [[ -n "$theme" ]]; then
        local theme_path="$HOME/.config/awesome/themes/$theme/theme.lua"
        if [[ -f "$theme_path" ]]; then
        awk -i inplace -v t="$theme" '/ theme =/ {gsub(/"[^"]+"/, "\""t"\"")} 1' ~/.config/awesome/rc.lua
        echo "Theme changed to '$theme'"
        sleep 1 && awesome-client 'awesome.restart()' > /dev/null 2>&1
        else
        echo "Invalid theme: '$theme'"
        fi
    fi
}

gtkset() { # commant to set gtk accent color
    COLORS=($(cat ~/.cache/wal/colors))
    I=3
    if [ -n "${COLORS[$I]}}" ]; then
        echo "Accent color of gtk darkarch changed to ${COLORS[$I]}"
        sed -i "s/@define-color accent #[^;]*;/@define-color accent ${COLORS[$I]};/g" $HOME/.local/share/themes/darkarch/gtk-3.0/gtk.css
    else
        echo "No color $I found in colors-kitty.conf"
    fi
}

walset() { # AwesomeWM pywall colors and background
    local usage="Usage: walset [OPTIONS]\n Options:
    -c,              Color set.
    -w,              Wallpaper set.
    -wc,             Wallpaper and Color set.
    -h, --help       Display this help message."
    local e=""
    local c=""
    local w=""
    while (( $# > 0 )); do
        case "$1" in
        -e) e="1" ;;
        -c) c="1" ;;
        -w) w="1" ;;
        -wc|-cw) w="1" ; c="1" ;;
        -h|--help)
            echo -e "$usage"
            return 0
            ;;
        *)
            echo "Error: Unknown option: $1"
            echo -e "$usage"
            return 1
            ;;
        esac
        shift
    done
    local theme=$(awk -F '"' '/ theme =/ {print $2}' ~/.config/awesome/rc.lua)
    local theme_path="$HOME/.config/awesome/themes/$theme/theme.lua"
    local wallpaper_current="$(awk -F '"' '/self\.wallpaper/ { print $2 }' "$theme_path")"
    local wallpapers=("${(@f)$(find "$HOME/.config/awesome/themes/$theme/" "$HOME/Pictures/Wallpapers" -maxdepth 2 -type f -iregex '.*\.\(jpe?g\|png\)' -not -name "$(basename "$wallpaper_current")")}")
    colorset() {
        wal -i "$wallpaper_path"
        local color_values=(
            "colormain=$(awk 'NR==6' "$palette_path")"
            "colorurgent=$(awk 'NR==5' "$palette_path")"
        )
        local theme_file="$(<"$theme_path")"
        for color in "${color_values[@]}"; do
            local color_name="${color%%=*}"
            local color_value="${color#*=}"
            theme_file="$(echo "$theme_file" | sed -E "s/^theme\.$color_name.*$/theme.$color_name = '$color_value'/")"
        done
        echo "$theme_file" > "$theme_path"
    }
    if [[ ${#wallpapers[@]} -eq 0 ]]; then
        echo "No wallpapers found in $HOME/Pictures/Wallpapers"
        return 1
    fi
    local selection=$(printf '%s\n' "${wallpapers[@]}" | fzf-images )
    if [[ -z "$selection" ]]; then
        echo "No wallpaper selected."
        return 1
    fi
    local wallpaper_path="$(realpath "$selection")"
    local palette_path="$HOME/.cache/wal/colors"
    if [[ -n "$c" && -n "$w" ]]; then # wallpaper selector to set walpaper and colors in awesomewm and other pywall supported
        sudo clear
        sed -i "s|self\.wallpaper =.*|self.wallpaper = \"$wallpaper_path\"|" "$theme_path"
        colorset
        pgrep swaybg >/dev/null 2>&1 && pkill swaybg && nohup $HOME/.config/hypr/bg >/dev/null 2>&1 &!
        if pgrep -x "awesome" >/dev/null 2>&1; then
        sleep 1 && awesome-refresh > /dev/null 2>&1
        fi
        papirus-folders-autocolor
        gtkset
        sudo chmod a+rw /etc/vconsole.conf
        ttywal       
        echo "Wallpaper changed to: $selection"
        return 0
    elif [[ -n "$c" ]]; then # wallpaper selector to set colors in awesomewm and other pywall supported
        colorset
        if pgrep -x "awesome" >/dev/null 2>&1; then
        sleep 1 && awesome-refresh > /dev/null 2>&1
        fi
        if pgrep -x "dwm" >/dev/null 2>&1; then
        sleep 1 && kill -TERM $(pidof dwm) > /dev/null 2>&1
        fi
        return 0
    elif [[ -n "$w" ]]; then # wallpaper selector to set walpaper in awesomewm and other pywall supported
        sed -i "s|self\.wallpaper =.*|self.wallpaper = \"$wallpaper_path\"|" "$theme_path"
        echo "$wallpaper_path" > "$HOME/.cache/wal/wal"
        pgrep swaybg >/dev/null 2>&1 && pkill swaybg && nohup $HOME/.config/hypr/bg >/dev/null 2>&1 &!
        if pgrep -x "awesome" >/dev/null 2>&1; then
        sleep 1 && awesome-refresh > /dev/null 2>&1
        fi
        if pgrep -x "dwm" >/dev/null 2>&1; then
        sleep 1 && kill -TERM $(pidof dwm) > /dev/null 2>&1
        fi
        echo "Wallpaper changed to: $selection"
        return 0
    else
        echo "Error: No options specified. Use -h or --help for usage."
        echo -e "$usage"
        return 1
    fi
}
